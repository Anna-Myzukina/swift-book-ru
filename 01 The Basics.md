
<h1>The Basics /  Основы</h1>

<b><ins>Swift </ins></b>- это новый язык программирования для разработки приложений для iOS, macOS, watchOS и tvOS.
Тем не менее, многие части Swift будут знакомы из вашего опыта разработки на C и Objective-C.

Swift предоставляет свои собственные версии всех основных типов C и Objective-C, включая Int для целых чисел, 
Double и Float для значений с плавающей запятой, Bool для логических значений и String для текстовых данных. 
Swift также предоставляет мощные версии трех основных типов коллекций, Array, Set и Dictionary,
как описано в <a href="https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html">Collection Types</a> 

Как и C, Swift использует переменные для хранения и обращения к значениям по идентифицирующему имени.
Swift также широко использует переменные, значения которых не могут быть изменены. 
Они известны как константы и являются гораздо более мощными, чем константы в C.
Константы используются в Swift, чтобы сделать код более безопасным и понятным, 
когда вы работаете со значениями, которые не нужно изменять.

В дополнение к знакомым типам, Swift представляет расширенные типы, которых нет в Objective-C, такие как кортежи.
Кортежи позволяют создавать и передавать группы значений. 
Вы можете использовать кортеж для возврата нескольких значений из функции в виде одного составного значения.

Swift также вводит необязательные/Optionals типы, которые обрабатывают отсутствие значения.
Необязательные/Optionals говорят, что «есть значение, и оно равно x», или «значение вообще не существует».
Использование Optionals похоже на использование nil с указателями в Objective-C, 
но они работают для любого типа, а не только для классов. 
Optionals опции не только более безопасны и более выразительны,
чем nil указатели в Objective-C, но и лежат в основе многих наиболее мощных функций Swift.

<b><ins>Swift</ins></b> - это типобезопасный язык, который означает, что он поможет вам понять типы значений, с которыми может работать ваш код.
Если часть вашего кода требует String, безопасность типа не позволяет вам передать ему Int по ошибке.
Аналогично, безопасность типов предотвращает случайную передачу optional String в фрагмент кода,
для которого требуется nonoptional String. 
Безопасность типов помогает выявлять и исправлять ошибки как можно раньше в процессе разработки.



<h2> Переменные и константы / Constants and Variables</h2>

Константы и переменные связывают имя (например, MaximumNumberOfLoginAttempts или welcomeMessage) 
со значением определенного типа (например, число 10 или строка «Hello»). 
Значение константы не может быть изменено после ее установки,
тогда как в будущем для переменной можно будет установить другое значение.

<h3>Объявление констант и переменных</h3>

Константы и переменные должны быть объявлены до их использования. 
Вы объявляете константы с ключевым словом let, а переменные с ключевым словом var. 
Вот пример того, как можно использовать константы и переменные для отслеживания количества попыток входа в систему, 
которые сделал пользователь:

    let maximumNumberOfLoginAttempts = 10
    var currentLoginAttempt = 0
    
Этот код можно прочитать как:

«Объявите новую константу с именем maximumNumberOfLoginAttempts и присвойте ей значение 10. 
Затем объявите новую переменную с именем currentLoginAttempt и присвойте ей начальное значение 0.»

В этом примере максимальное количество разрешенных попыток входа в систему объявляется как константа, поскольку максимальное значение никогда не изменяется. Текущий счетчик попыток входа в систему объявлен как переменная, потому что это значение должно увеличиваться после каждой неудачной попытки входа в систему.


<h4>Вы можете объявить несколько констант или несколько переменных в одной строке, разделенных запятыми:</h4>   

    | var x = 0.0, y = 0.0, z = 0.0
    
    |Если сохраненное значение в вашем коде не изменится, всегда объявляйте его как константу с ключевым словом let. 
    |Используйте переменные только для хранения значений, которые должны быть в состоянии изменить.


<h3>Тип Аннотации  / Type Annotations</h3>

Вы можете предоставить аннотацию типа при объявлении константы или переменной, чтобы иметь представление о типе значений, которые константа или переменная могут хранить. 
Напишите аннотацию типа, поместив двоеточие после имени константы или переменной, за которым следует пробел, а затем имя используемого типа.

Этот пример предоставляет аннотацию типа для переменной с именем welcomeMessage, чтобы указать, 
что переменная может хранить значения String:


    | var welcomeMessage: String

Двоеточие в объявлении означает «… тип…», поэтому приведенный выше код можно прочитать как:

    «Объявите переменную с именем welcomeMessage типа String».


Фраза «тип String» означает «может хранить любое значение String». 
Думайте о нем как о значении «тип вещи» (или «вид вещи»), который может быть сохранен.

Переменная welcomeMessage теперь может быть установлена на любое строковое значение без ошибки:

    | welcomeMessage = "Hello"

Вы можете определить несколько связанных переменных одного и того же типа в одной строке,
разделенных запятыми, с аннотацией одного типа после окончательного имени переменной:

    | var red, green, blue: Double


      На практике редко нужно писать аннотации типов. Если вы укажете начальное значение для константы или переменной в точке,
      которую она определила, Swift почти всегда может определить тип, который будет использоваться для этой константы или
      переменной, как описано в Тип безопасности и Вывод типа. В приведенном выше примере welcomeMessage начальное значение не
      указывается, поэтому тип переменной welcomeMessage указывается с аннотацией типа, а не выводится из начального значения.
      
<h3>Именование констант и переменных : </h3> 

Имена констант и переменных могут содержать практически любой символ, включая символы Юникода:

            1 | let π = 3.14159
            2 | let 你好 = "你好世界"
            3 | let 🐶🐮 = "dogcow"


Имена констант и переменных не могут содержать пробельные символы, математические символы, стрелки, 
скалярные значения Unicode для частного использования или символы рисования линий и рамок.
И при этом они не могут начинаться с числа, хотя числа могут быть включены в другом месте в имени.

После того, как вы объявили константу или переменную определенного типа, 
вы не можете объявить ее снова с тем же именем или изменить ее для хранения значений другого типа.
Вы также не можете изменить константу в переменную или переменную в константу.

        | Если вам нужно присвоить константе или переменной то же имя, 
        | что и зарезервированному ключевому слову Swift, заключите его в кавычки (') 
        | при использовании его в качестве имени.
        | Однако избегайте использования ключевых слов в качестве имен, 
        | если у вас нет абсолютно никакого выбора.
        

Вы можете изменить значение существующей переменной на другое значение совместимого типа. 
В этом примере значение friendlyWelcome изменяется с «Hello!» на "Bonjour!"


            1 | var friendlyWelcome = "Hello!"
            2 | friendlyWelcome = "Bonjour!"
            3 | // friendlyWelcome is now "Bonjour!"
            
            
В отличие от переменной, значение константы не может быть изменено после ее установки. 
Попытка сделать это сообщается как ошибка при компиляции вашего кода:
            
            
            1 | let languageName = "Swift"
            2 | languageName = "Swift++"
            3 | // This is a compile-time error: languageName cannot be changed.


<h3>Print() Константы и переменные </h3> 

Вы можете напечатать текущее значение константы или переменной с помощью 
функции print (_: separator: terminator :):
            
            1 | print(friendlyWelcome)
            2 | // Prints "Bonjour!"
            
Функция print (_: separator: terminator :) - это глобальная функция, которая печатает одно или несколько значений в соответствующий вывод.
Например, в XCode функция print (_: separator: terminator :) выводит свой вывод в «консольную» панель XCode.

Параметры (_: separator: terminator :) -  имеют значения по умолчанию, поэтому их можно опустить при вызове этой функции.   
По умолчанию функция завершает строку, которую печатает, добавляя разрыв строки.            
Чтобы напечатать значение без разрыва строки после него, передайте пустую строку в качестве терминатора, например 

        1 | print (someValue, terminator: "").            
Для получения информации о параметрах со значениями по умолчанию 
см. Значения параметров по умолчанию. 
<a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID169">Default Parameter Values.</a>

Swift использует <em>строковую интерполяцию</em>, чтобы включить имя константы или переменной в качестве заполнителя в более длинную строку и предложить Swift заменить его текущим значением этой константы или переменной.

Оберните имя в круглых скобках и экранируйте его обратной косой чертой перед открывающей скобкой:

        1 | print("The current value of friendlyWelcome is \(friendlyWelcome)")
        2 | // Prints "The current value of friendlyWelcome is Bonjour!"
        
    Все параметры, которые вы можете использовать со строковой интерполяцией, 
    описаны в разделе <a href="https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID292">Строковая интерполяция.</a>


 <h2>Коментарии :</h2>

Используйте комментарии, чтобы включить неисполняемый текст в свой код, как примечание или напоминание для себя.
Комментарии <b>игнорируются</b> компилятором Swift при компиляции вашего кода.

Комментарии в Swift очень похожи на комментарии в C. 
Однострочные комментарии начинаются с двух косых черт (//):


        // This is a comment.

Многострочные комментарии начинаются с косой черты, за которой следует звездочка (/ *), 
и заканчиваются звездочкой, за которой следует косая черта (* /):

        /* This is also a comment
        but is written over multiple lines. */


В отличие от многострочных комментариев в C, многострочные комментарии в Swift могут быть вложены в другие многострочные комментарии.
Вы пишете вложенные комментарии, запуская блок многострочных комментариев, а затем начиная второй многострочный комментарий в первом блоке.
Затем закрывается второй блок, за которым следует первый блок:

        /* This is the start of the first multiline comment.
         /* This is the second, nested multiline comment. */
        This is the end of the first multiline comment. */
        
Вложенные многострочные комментарии позволяют быстро и легко комментировать большие блоки кода, 
даже если код уже содержит многострочные комментарии.

<h2>Точка с запятой</h2>

В отличие от многих других языков, Swift не требует от вас писать точку с запятой (;) 
после каждого оператора в вашем коде, хотя вы можете сделать это, если хотите.
Однако точки с запятой необходимы, если вы хотите написать несколько отдельных операторов в одной строке:


            1 | let cat = "🐱"; print(cat)
            2 | // Prints "🐱"
<h2>Целые числа </h2>

<b><ins>Целые числа</ins></b> - это целые числа без дробной составляющей, такие как 42 и -23.
Целые числа либо со <ins>знаком</ins> (положительный, ноль или отрицательный), либо <ins>без знака</ins> (положительный или ноль).

Swift предоставляет целые числа со знаком и без знака в 8, 16, 32 и 64-битных формах.

        Эти целые числа следуют соглашению об именах, аналогичному C, 
        в котором 8-разрядное целое число без знака имеет тип UInt8, 
        а 32-разрядное целое число со знаком имеет тип Int32.

Как и все типы в Swift, эти целочисленные типы имеют заглавные имена.

<h3>Целочисленные границы </h3>

Вы можете получить доступ к минимальным и максимальным значениям каждого целочисленного типа с помощью свойств <b>min и max:</b>

        1 | let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
        2 | let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8

Значения этих свойств относятся к типу чисел соответствующего размера 
(например, UInt8 в приведенном выше примере) 
и поэтому могут использоваться в выражениях вместе с другими значениями того же типа.


<h3>Int</h3>

В большинстве случаев вам не нужно выбирать конкретный размер целого числа для использования в вашем коде. 
Swift предоставляет дополнительный целочисленный тип Int, который имеет тот же размер, 
что и собственный размер текущей платформы:

        * On a 32-bit platform, Int is the same size as Int32.
        * On a 64-bit platform, Int is the same size as Int64.

Если вам не нужно работать с определенным размером целого числа, 
всегда используйте Int для целочисленных значений в вашем коде.

Это помогает согласованности кода и совместимости. 
Даже на 32-разрядных платформах Int может хранить любое значение от -2 147 483 648 до 2 147 483 647 
и является достаточно большим для многих целочисленных диапазонов.

<h3>UInt</h3> 

Swift также предоставляет целочисленный тип без знака, UInt, который имеет тот же размер, что и собственный размер текущей платформы:

            * On a 32-bit platform, UInt is the same size as UInt32.
            * On a 64-bit platform, UInt is the same size as UInt64.


    Используйте UInt только тогда, когда вам нужен целочисленный тип без знака с тем же размером, 
    что и собственный размер платформы.
    Если это не так, предпочтительнее Int, даже когда известно, что значения, 
    которые должны быть сохранены, неотрицательны.
    Последовательное использование Int для целочисленных значений способствует совместимости кода,
    устраняет необходимость преобразования между различными типами чисел и 
    соответствует выводу целочисленных типов, как описано в разделе  <a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID322">Type Safety and Type Inference.</a>

<h2>Числа с плавающей точкой / Floating-Point Numbers</h2>

<b>Числа с плавающей точкой</b> - это числа с дробной составляющей, такие как 3.14159, 0.1 и -273.15.

Типы с плавающей точкой могут представлять гораздо более широкий диапазон значений, чем целочисленные типы, 
и могут хранить числа, которые намного больше или меньше, чем могут быть сохранены в Int.

<ins>Swift предоставляет два типа чисел с плавающей точкой:<ins>

    <b>- Double</b> represents a 64-bit floating-point number.
    <b>- Float</b> represents a 32-bit floating-point number.

<b>Double имеет точность не менее 15 десятичных цифр, тогда как точность Float может составлять всего 6 десятичных цифр.
Соответствующий тип с плавающей точкой для использования зависит от природы и диапазона значений, 
с которыми вам нужно работать в вашем коде. В ситуациях, когда подходит любой тип, предпочтительнее Double.</b>

<h2>Тип безопасности и вывод типа</h2>

<b>Swift </b>- это язык, безопасный для типов.
Безопасный тип языка предлагает вам четко определить типы значений, с которыми может работать ваш код.
Если часть вашего кода требует <b>String</b>, вы не можете передать ему <b>Int</b> по ошибке.

Поскольку Swift является безопасным в использовании типов, он выполняет проверки типов при компиляции кода 
и помечает любые несовпадающие типы как ошибки.
Это позволяет вам выявлять и исправлять ошибки как можно раньше в процессе разработки.

Проверка типов помогает избежать ошибок при работе с различными типами значений.
Однако это не означает, что вы должны указывать тип каждой константы и переменной, которые вы объявляете.
Если вы не указали требуемый тип значения, Swift использует определение типа для определения подходящего типа.

Вывод типа позволяет компилятору автоматически определять тип определенного выражения при компиляции вашего кода, просто проверяя предоставленные вами значения.

Из-за вывода типов Swift требует гораздо меньше объявлений типов, чем такие языки, как C или Objective-C.
Константы и переменные по-прежнему явно типизированы, но большая часть работы по определению их типа сделана за вас.

Вывод типа особенно полезен, когда вы объявляете константу или переменную с начальным значением.
Это часто делается путем присвоения литерального значения (или литерала) константе или переменной в точке, в которой вы ее объявляете.
(Литеральное значение - это значение, которое отображается непосредственно в вашем исходном коде, например, 42 и 3.14159 в приведенных ниже примерах.)

Например, если вы присваиваете литералу значение 42 для новой константы, не говоря, какого она типа, 
Swift выведет, что вы хотите, чтобы константа была Int, потому что вы инициализировали ее числом, 
которое выглядит как целое число:

        let meaningOfLife = 42
        // meaningOfLife is inferred to be of type Int

Аналогично, если вы не указали тип литерала с плавающей запятой, Swift решит, что вы хотите создать Double:

        let pi = 3.14159
        // pi is inferred to be of type Double

Swift всегда выбирает Double (вместо Float), когда выводит тип чисел с плавающей точкой.

Если вы комбинируете целочисленные литералы и литералы с плавающей точкой в ​​выражении,
тип Double будет выведен из контекста:

        let anotherPi = 3 + 0.14159
        // anotherPi is also inferred to be of type Double

Буквальное значение <b>3 </b>не имеет явного типа само по себе, 
и поэтому соответствующий тип вывода Double выводится из-за 
присутствия литерала с плавающей запятой как части сложения.


<h2>Числовые литералы / Numeric Literals </h2>

<b>Целочисленные литералы могут быть записаны как:</b>

        - Десятичное число без префикса 
        - Двоичное число с префиксом -> 0b 
        - Восьмеричное число с префиксом -> 0o 
        - Шестнадцатеричное число с префиксом -> 0x

Все эти целочисленные литералы имеют десятичное значение 17:

        1 | let decimalInteger = 17
        2 | let binaryInteger = 0b10001       // 17 в двоичной записи
        3 | let octalInteger = 0o21           // 17 в восьмиричной записи
        4 | let hexadecimalInteger = 0x11     // 17 в шестнадцатиричной записи


Литералы с плавающей точкой могут быть десятичными (без префикса) или шестнадцатеричными (с префиксом 0x).
Они всегда должны иметь число (или шестнадцатеричное число) по обе стороны от десятичной точки.
Десятичные числа с плавающей запятой также могут иметь необязательный показатель степени, 
обозначаемый прописными или строчными буквами e; 
шестнадцатеричные числа с плавающей точкой должны иметь показатель степени, обозначенный заглавными или строчными буквами p.

Для десятичных чисел с показателем степени exp базовое число умножается на 10exp:

        1.25e2 means 1.25 x 102, or 125.0.
        1.25e-2 means 1.25 x 10-2, or 0.0125.


Для шестнадцатеричных чисел с показателем степени exp базовое число умножается на 2exp:

        0xFp2 means 15 x 22, or 60.0.
        0xFp-2 means 15 x 2-2, or 3.75.




Все эти литералы с плавающей точкой имеют десятичное значение 12,1875:


        let decimalDouble = 12.1875
        let exponentDouble = 1.21875e1
        let hexadecimalDouble = 0xC.3p0

Числовые литералы могут содержать дополнительное форматирование, чтобы их было легче читать.
И целые числа, и числа с плавающей точкой могут быть дополнены дополнительными нулями и могут содержать подчеркивания,
чтобы было удобно читать код. Ни один из типов форматирования не влияет на базовое значение литерала:

        let paddedDouble = 000123.456
        let oneMillion = 1_000_000
        let justOverOneMillion = 1_000_000.000_000_1
        
        
        
  <h2> Числовое Преобразование Типа  / Numeric Type Conversion </h2>
        
Используйте тип <b>Int</b> для всех целочисленных констант общего назначения и переменных в вашем коде
даже если известно, что они неотрицательны.     
Использование целочисленного типа по умолчанию в повседневных ситуациях означает, 
что целочисленные константы и переменные немедленно взаимодействуют в вашем коде 
и будут соответствовать выведенному типу для целочисленных литеральных значений.        
   
Используйте другие целочисленные типы только в том случае, если они особенно необходимы для выполняемой задачи,
из-за явного размера данных из внешнего источника или для производительности, 
использования памяти или другой необходимой оптимизации.  
   
Использование типов с явно заданными размерами в этих ситуациях помогает уловить 
любые случайные переполнения значений 
и неявно документирует природу используемых данных.        
        
  <h3>Целочисленное преобразование</h3>
  
Диапазон чисел, которые могут быть сохранены в целочисленной константе или переменной,
различен для каждого числового типа.
        
        Константа или переменная Int8 может хранить числа от -128 до 127
        
 в то время как
 
        Константа или переменная UInt8 может хранить числа от 0 до 255
        
Число, которое не помещается в константу или переменную целочисленного типа размера, 
сообщается как ошибка при компиляции кода:        
        
        
        let cannotBeNegative: UInt8 = -1
        // UInt8 cannot store negative numbers, and so this will report an error
        
        let tooBig: Int8 = Int8.max + 1
        // Int8 cannot store a number larger than its maximum value,
        // and so this will also report an error
        
        
  Поскольку каждый числовой тип может хранить различный диапазон значений, 
  вы должны выбрать преобразование числового типа в каждом конкретном случае.      
  Этот дополнительный подход предотвращает скрытые ошибки преобразования 
  и помогает четко определить намерения преобразования типа в вашем коде.      
        
  Чтобы преобразовать один конкретный тип номера в другой, вы инициализируете новый номер нужного типа с существующим значением.      
  В приведенном ниже примере константа twoThousand имеет тип UInt16, тогда как константа one - типа UInt8.      
  Они не могут быть добавлены вместе напрямую, потому что они не одного типа.      
  Вместо этого в этом примере вызывается UInt16 (one) для создания нового UInt16, 
  инициализированного значением one, и использует это значение вместо оригинала:

        let twoThousand: UInt16 = 2_000
        let one: UInt8 = 1
        let twoThousandAndOne = twoThousand + UInt16(one)

Поскольку обе стороны сложения теперь имеют тип UInt16, сложение разрешено.
Предполагается, что на выходе константа (twoThousandAndOne) имеет тип UInt16, поскольку она является суммой двух значений UInt16.

<b>SomeType (ofInitialValue)</b> является способом по умолчанию для вызова инициализатора типа Swift 
и передачи начального значения.
Под капотом UInt16 имеет инициализатор, который принимает значение UInt8, 
и поэтому этот инициализатор используется для создания нового UInt16 из существующего UInt8.
Однако вы не можете передавать здесь любой тип - это должен быть тип, для которого UInt16 предоставляет инициализатор.
Расширение существующих типов для обеспечения инициализаторов, которые принимают новые типы (включая ваши собственные определения типов), рассматривается в главе "Расширения"  <a href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html">Extensions.</a>


<h3>Целочисленное преобразование и преобразование с плавающей точкой</h3>

Преобразования между целочисленными и числовыми типами с плавающей точкой должны быть явными:

       | let three = 3
       | let pointOneFourOneFiveNine = 0.14159
       | let pi = Double(three) + pointOneFourOneFiveNine
        
        // pi equals 3.14159, and is inferred to be of type Double
        //Здесь значение константы три используется для создания нового значения типа Double, 
        //так что обе стороны сложения имеют одинаковый тип.

Без этого преобразования добавление не будет разрешено.

Преобразование с плавающей точкой в ​​целое также должно быть сделано явным. 
Целочисленный тип может быть инициализирован значением Double или Float:

        |let integerPi = Int(pi)
        
        // integerPi equals 3, and is inferred to be of type Int
Значения с плавающей точкой всегда усекаются при использовании для 
инициализации нового целочисленного значения таким способом. 

        Это означает, что 4,75 становится 4, а -3,9 становится -3.


        Правила объединения числовых констант и переменных отличаются от правил для числовых литералов.
        Литеральное значение 3 может быть добавлено непосредственно к литеральному значению 0.14159, 
        поскольку числовые литералы не имеют явного типа сами по себе.
        Их тип выводится только в тот момент, когда они оцениваются компилятором.
        
<h2> Тип Алиасы / Type Aliases </h2>      
        
Тип Алиасы - определяют альтернативное имя для существующего типа. 
Тип Алиасы - определяются с помощью ключевого слова typealias.
Тип Алиасы -полезны, когда вы хотите сослаться на существующий тип по имени, которое контекстуально более уместно, 
например, при работе с данными определенного размера из внешнего источника:   
        
        typealias AudioSample = UInt16
 
 Определив Тип Алиасы, вы можете использовать алиасы везде, где вы можете использовать исходное имя:       
        
        var maxAmplitudeFound = AudioSample.min
        // maxAmplitudeFound is now 0
        
 Здесь AudioSample определяется как псевдоним для UInt16. 
 Поскольку это алиас, вызов AudioSample.min фактически вызывает UInt16.min, 
 который предоставляет начальное значение 0 для переменной maxAmplitudeFound.       
        
  
  <h2> Логические типы / Booleans<h2>
    
  Swift имеет базовый логический тип, называемый Bool. 
  Логические значения называются логическими, потому что они могут быть только истинными или ложными. 
  
  <b>Swift предоставляет два значения логических констант: true и false:</b>
        
        
        let orangesAreOrange = true
        let turnipsAreDelicious = false
   
   Типы orangesAreOrange и turnipsAreDelicious были определены как Bool т.к., 
   они были инициализированы с логическими значениями литералов.     
        
   Как и в случае с Int и Double , вам не нужно объявлять константы или переменные как Bool, 
   если присваиваете им значение true или false, при создании.     
   Вывод типа помогает сделать код Swift более кратким и читаемым, 
   когда инициализирует константы или переменные с другими значениями, тип которых уже известен.
        
   Логические значения особенно полезны, когда вы работаете с условными операторами, такими как оператор if:     
        
        
            if turnipsAreDelicious {
                
                print("Mmm, tasty turnips!")
            
            } else {
                
                print("Eww, turnips are horrible.")
            }
            
            // Prints "Eww, turnips are horrible."     
        
   Условные операторы, такие как оператор if, более подробно описаны в главе <a href="https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html">Control Flow.</a>     
        
Безопасность типов Swift предотвращает замену Bool не-булевыми значениями. 

Следующий пример сообщает об ошибке времени компиляции:
        
        let i = 1
        
        if i {
        // this example will not compile, and will report an error
        }

Тем не менее, приведенный ниже альтернативный пример действителен:

        let i = 1
        if i == 1 {
            // this example will compile successfully
        }

Результат сравнения i == 1 имеет тип Bool, поэтому второй пример проходит проверку типа.
Сравнения типа i == 1 обсуждаются в разделе «Основные операторы».


Как и в случае с другими примерами безопасности типов в Swift, этот подход позволяет избежать случайных ошибок и гарантирует, что цель конкретного раздела кода всегда чистая.

<h2>Кортеж / Tuples</h2>

<b><ins>Кортежи</ins></b> группируют несколько значений в одно составное значение. 
Значения в кортеже могут быть любого типа и не обязательно должны быть одного типа друг с другом.

В этом примере (404, «Not Found») - это кортеж, который описывает код состояния HTTP. 
Код состояния HTTP - это специальное значение, возвращаемое веб-сервером каждый раз, когда вы запрашиваете веб-страницу.
Код состояния 404 Not Found возвращается, если вы запрашиваете несуществующую веб-страницу.


        let http404Error = (404, "Not Found")
        // http404Error is of type (Int, String), and equals (404, "Not Found")

Кортеж (404, «Not Found») группирует Int и String, чтобы дать коду статуса HTTP два отдельных значения:
число и удобочитаемое описание. 
Его можно описать как «кортеж типа (Int, String)».

Вы можете создавать кортежи из любой перестановки типов, и они могут содержать столько разных типов, сколько вам нужно. 
Ничто не мешает вам иметь кортеж типа (Int, Int, Int) или (String, Bool), 
или даже любую другую перестановку, которая вам требуется.


Вы можете <em>разложить</em> содержимое кортежа на отдельные константы или переменные, 
к которым вы затем получите доступ, как обычно:

        let (statusCode, statusMessage) = http404Error
        print("The status code is \(statusCode)")    // Prints "The status code is 404"
        
        print("The status message is \(statusMessage)")   // Prints "The status message is Not Found"
        

Если вам нужны только некоторые значения кортежа, игнорируйте части кортежа с подчеркиванием (_) 
при decompose / разворачивании кортежа:


        let (justTheStatusCode, _) = http404Error
        print("The status code is \(justTheStatusCode)")   // Prints "The status code is 404"
        
В качестве альтернативы, получить доступ к значениям отдельных элементов в кортеже, используя номера индекса,
начинающиеся с нуля:

        let http404Error = (404, "Not Found")
        print("The status code is \(http404Error.0)")   // Prints "The status code is 404"
        print("The status message is \(http404Error.1)")  // Prints "The status message is Not Found"
        
Вы можете назвать отдельные элементы в кортеже, когда кортеж определен:

        let http200Status = (statusCode: 200, description: "OK")

Если вы называете элементы в кортеже, вы можете использовать имена элементов для доступа к значениям этих элементов:
        
        let http200Status = (statusCode: 200, description: "OK")
        print("The status code is \(http200Status.statusCode)")  // Prints "The status code is 200 "
        print("The status message is \(http200Status.description)")  // Prints "The status message is OK"
        
 Кортежи особенно полезны в качестве возвращаемых значений функций. 
 Функция, которая пытается получить веб-страницу, может возвращать тип кортежа (Int, String), 
 чтобы описать успех или неудачу поиска страницы.       

Возвращая кортеж с двумя различными значениями, каждый из которых имеет свой тип, 
функция предоставляет более полезную информацию о своем результате, 
чем если бы она могла вернуть только одно значение одного типа.

Для получения дополнительной информации см. <a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID164">Функции с несколькими возвращаемыми значениями.</a>


            Кортежи полезны для временных групп связанных значений. 
            Они не подходят для создания сложных структур данных. 
            Если ваша структура данных может сохраняться за пределами временной области, 
            смоделируйте ее как класс или структуру, а не как кортеж.
            Для получения дополнительной информации см. Структуры и классы.

<h2>Optionals</h2>

Вы используете дополнительные функции в ситуациях, когда значение может отсутствовать. 
Optionals представляет две возможности:
Либо есть значение, и вы можете развернуть Optional для доступа к этому значению, 
либо значение вообще не существует.

        Концепция Optionals не существует в C или Objective-C. 
        Самая близкая вещь в Objective-C - это возможность вернуть nil из метода, 
        который иначе возвратил бы объект, при этом nil означает «отсутствие действительного объекта.»
        Однако это работает только для объектов - это не работает для структур, базовых типов C или значений перечисления. 
        Для этих типов методы Objective C обычно возвращают специальное значение (такое как NSNotFound), чтобы указать на               отсутствие значения.


        Этот подход предполагает, что вызывающий метод знает, что существует специальное значение для проверки, 
        и не забывает проверять его. Optionals Swift позволяют вам указать отсутствие значения для любого типа 
        вообще без необходимости использования специальных констант.











