
<h1> Основы : </h1>

<a href="#p1" >=>Переменные и константы</a><ins><br>




<b><ins>Swift </ins></b>- это новый язык программирования для разработки приложений для iOS, macOS, watchOS и tvOS.
Тем не менее, многие части Swift будут знакомы из вашего опыта разработки на C и Objective-C.

Swift предоставляет свои собственные версии всех основных типов C и Objective-C, включая Int для целых чисел, 
Double и Float для значений с плавающей запятой, Bool для логических значений и String для текстовых данных. 
Swift также предоставляет мощные версии трех основных типов коллекций, Array, Set и Dictionary,
как описано в <a href="https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html">Collection Types</a> 

Как и C, Swift использует переменные для хранения и обращения к значениям по идентифицирующему имени.
Swift также широко использует переменные, значения которых не могут быть изменены. 
Они известны как константы и являются гораздо более мощными, чем константы в C.
Константы используются в Swift, чтобы сделать код более безопасным и понятным, 
когда вы работаете со значениями, которые не нужно изменять.

В дополнение к знакомым типам, Swift представляет расширенные типы, которых нет в Objective-C, такие как кортежи.
Кортежи позволяют создавать и передавать группы значений. 
Вы можете использовать кортеж для возврата нескольких значений из функции в виде одного составного значения.

Swift также вводит необязательные/Optionals типы, которые обрабатывают отсутствие значения.
Необязательные/Optionals говорят, что «есть значение, и оно равно x», или «значение вообще не существует».
Использование Optionals похоже на использование nil с указателями в Objective-C, 
но они работают для любого типа, а не только для классов. 
Optionals опции не только более безопасны и более выразительны,
чем nil указатели в Objective-C, но и лежат в основе многих наиболее мощных функций Swift.

<b><ins>Swift</ins></b> - это типобезопасный язык, который означает, что он поможет вам понять типы значений, с которыми может работать ваш код.
Если часть вашего кода требует String, безопасность типа не позволяет вам передать ему Int по ошибке.
Аналогично, безопасность типов предотвращает случайную передачу optional String в фрагмент кода,
для которого требуется nonoptional String. 
Безопасность типов помогает выявлять и исправлять ошибки как можно раньше в процессе разработки.



<p id="p1"><h2> Переменные и константы </h2></p1>

Константы и переменные связывают имя (например, MaximumNumberOfLoginAttempts или welcomeMessage) 
со значением определенного типа (например, число 10 или строка «Hello»). 
Значение константы не может быть изменено после ее установки,
тогда как в будущем для переменной можно будет установить другое значение.

<h3>Объявление констант и переменных</h3>

Константы и переменные должны быть объявлены до их использования. 
Вы объявляете константы с ключевым словом let, а переменные с ключевым словом var. 
Вот пример того, как можно использовать константы и переменные для отслеживания количества попыток входа в систему, 
которые сделал пользователь:

    let maximumNumberOfLoginAttempts = 10
    var currentLoginAttempt = 0
    
Этот код можно прочитать как:

«Объявите новую константу с именем maximumNumberOfLoginAttempts и присвойте ей значение 10. 
Затем объявите новую переменную с именем currentLoginAttempt и присвойте ей начальное значение 0.»

В этом примере максимальное количество разрешенных попыток входа в систему объявляется как константа, поскольку максимальное значение никогда не изменяется. Текущий счетчик попыток входа в систему объявлен как переменная, потому что это значение должно увеличиваться после каждой неудачной попытки входа в систему.


<h4>Вы можете объявить несколько констант или несколько переменных в одной строке, разделенных запятыми:</h4>   

    | var x = 0.0, y = 0.0, z = 0.0
    
    |Если сохраненное значение в вашем коде не изменится, всегда объявляйте его как константу с ключевым словом let. 
    |Используйте переменные только для хранения значений, которые должны быть в состоянии изменить.


<h3>Тип Аннотации  s</h3>

Вы можете предоставить аннотацию типа при объявлении константы или переменной, чтобы иметь представление о типе значений, которые константа или переменная могут хранить. 
Напишите аннотацию типа, поместив двоеточие после имени константы или переменной, за которым следует пробел, а затем имя используемого типа.

Этот пример предоставляет аннотацию типа для переменной с именем welcomeMessage, чтобы указать, 
что переменная может хранить значения String:


    | var welcomeMessage: String

Двоеточие в объявлении означает «… тип…», поэтому приведенный выше код можно прочитать как:

    «Объявите переменную с именем welcomeMessage типа String».


Фраза «тип String» означает «может хранить любое значение String». 
Думайте о нем как о значении «тип вещи» (или «вид вещи»), который может быть сохранен.

Переменная welcomeMessage теперь может быть установлена на любое строковое значение без ошибки:

    | welcomeMessage = "Hello"

Вы можете определить несколько связанных переменных одного и того же типа в одной строке,
разделенных запятыми, с аннотацией одного типа после окончательного имени переменной:

    | var red, green, blue: Double


      На практике редко нужно писать аннотации типов. Если вы укажете начальное значение для константы или переменной в точке,
      которую она определила, Swift почти всегда может определить тип, который будет использоваться для этой константы или
      переменной, как описано в Тип безопасности и Вывод типа. В приведенном выше примере welcomeMessage начальное значение не
      указывается, поэтому тип переменной welcomeMessage указывается с аннотацией типа, а не выводится из начального значения.
      
<h3>Именование констант и переменных : </h3> 

Имена констант и переменных могут содержать практически любой символ, включая символы Юникода:

            1 | let π = 3.14159
            2 | let 你好 = "你好世界"
            3 | let 🐶🐮 = "dogcow"


Имена констант и переменных не могут содержать пробельные символы, математические символы, стрелки, 
скалярные значения Unicode для частного использования или символы рисования линий и рамок.
И при этом они не могут начинаться с числа, хотя числа могут быть включены в другом месте в имени.

После того, как вы объявили константу или переменную определенного типа, 
вы не можете объявить ее снова с тем же именем или изменить ее для хранения значений другого типа.
Вы также не можете изменить константу в переменную или переменную в константу.

        | Если вам нужно присвоить константе или переменной то же имя, 
        | что и зарезервированному ключевому слову Swift, заключите его в кавычки (') 
        | при использовании его в качестве имени.
        | Однако избегайте использования ключевых слов в качестве имен, 
        | если у вас нет абсолютно никакого выбора.
        

Вы можете изменить значение существующей переменной на другое значение совместимого типа. 
В этом примере значение friendlyWelcome изменяется с «Hello!» на "Bonjour!"


            1 | var friendlyWelcome = "Hello!"
            2 | friendlyWelcome = "Bonjour!"
            3 | // friendlyWelcome is now "Bonjour!"
            
            
В отличие от переменной, значение константы не может быть изменено после ее установки. 
Попытка сделать это сообщается как ошибка при компиляции вашего кода:
            
            
            1 | let languageName = "Swift"
            2 | languageName = "Swift++"
            3 | // This is a compile-time error: languageName cannot be changed.


<h3>Print() Константы и переменные </h3> 

Вы можете напечатать текущее значение константы или переменной с помощью 
функции print (_: separator: terminator :):
            
            1 | print(friendlyWelcome)
            2 | // Prints "Bonjour!"
            
Функция print (_: separator: terminator :) - это глобальная функция, которая печатает одно или несколько значений в соответствующий вывод.
Например, в XCode функция print (_: separator: terminator :) выводит свой вывод в «консольную» панель XCode.

Параметры (_: separator: terminator :) -  имеют значения по умолчанию, поэтому их можно опустить при вызове этой функции.   
По умолчанию функция завершает строку, которую печатает, добавляя разрыв строки.            
Чтобы напечатать значение без разрыва строки после него, передайте пустую строку в качестве терминатора, например 

        1 | print (someValue, terminator: "").            
Для получения информации о параметрах со значениями по умолчанию 
см. Значения параметров по умолчанию. 
<a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID169">Default Parameter Values.</a>

Swift использует <em>строковую интерполяцию</em>, чтобы включить имя константы или переменной в качестве заполнителя в более длинную строку и предложить Swift заменить его текущим значением этой константы или переменной.

Оберните имя в круглых скобках и экранируйте его обратной косой чертой перед открывающей скобкой:

        1 | print("The current value of friendlyWelcome is \(friendlyWelcome)")
        2 | // Prints "The current value of friendlyWelcome is Bonjour!"
        
    Все параметры, которые вы можете использовать со строковой интерполяцией, 
    описаны в разделе <a href="https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID292">Строковая интерполяция.</a>


 <h2>Коментарии :</h2>

Используйте комментарии, чтобы включить неисполняемый текст в свой код, как примечание или напоминание для себя.
Комментарии <b>игнорируются</b> компилятором Swift при компиляции вашего кода.

Комментарии в Swift очень похожи на комментарии в C. 
Однострочные комментарии начинаются с двух косых черт (//):


        // This is a comment.

Многострочные комментарии начинаются с косой черты, за которой следует звездочка (/ *), 
и заканчиваются звездочкой, за которой следует косая черта (* /):

        /* This is also a comment
        but is written over multiple lines. */


В отличие от многострочных комментариев в C, многострочные комментарии в Swift могут быть вложены в другие многострочные комментарии.
Вы пишете вложенные комментарии, запуская блок многострочных комментариев, а затем начиная второй многострочный комментарий в первом блоке.
Затем закрывается второй блок, за которым следует первый блок:

        /* This is the start of the first multiline comment.
         /* This is the second, nested multiline comment. */
        This is the end of the first multiline comment. */
        
Вложенные многострочные комментарии позволяют быстро и легко комментировать большие блоки кода, 
даже если код уже содержит многострочные комментарии.

<h2>Точка с запятой</h2>

В отличие от многих других языков, Swift не требует от вас писать точку с запятой (;) 
после каждого оператора в вашем коде, хотя вы можете сделать это, если хотите.
Однако точки с запятой необходимы, если вы хотите написать несколько отдельных операторов в одной строке:


            1 | let cat = "🐱"; print(cat)
            2 | // Prints "🐱"
<h2>Целые числа </h2>

<b><ins>Целые числа</ins></b> - это целые числа без дробной составляющей, такие как 42 и -23.
Целые числа либо со <ins>знаком</ins> (положительный, ноль или отрицательный), либо <ins>без знака</ins> (положительный или ноль).

Swift предоставляет целые числа со знаком и без знака в 8, 16, 32 и 64-битных формах.

        Эти целые числа следуют соглашению об именах, аналогичному C, 
        в котором 8-разрядное целое число без знака имеет тип UInt8, 
        а 32-разрядное целое число со знаком имеет тип Int32.

Как и все типы в Swift, эти целочисленные типы имеют заглавные имена.

<h3>Целочисленные границы </h3>

Вы можете получить доступ к минимальным и максимальным значениям каждого целочисленного типа с помощью свойств <b>min и max:</b>

        1 | let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
        2 | let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8

Значения этих свойств относятся к типу чисел соответствующего размера 
(например, UInt8 в приведенном выше примере) 
и поэтому могут использоваться в выражениях вместе с другими значениями того же типа.


<h3>Int</h3>

В большинстве случаев вам не нужно выбирать конкретный размер целого числа для использования в вашем коде. 
Swift предоставляет дополнительный целочисленный тип Int, который имеет тот же размер, 
что и собственный размер текущей платформы:

        * On a 32-bit platform, Int is the same size as Int32.
        * On a 64-bit platform, Int is the same size as Int64.

Если вам не нужно работать с определенным размером целого числа, 
всегда используйте Int для целочисленных значений в вашем коде.

Это помогает согласованности кода и совместимости. 
Даже на 32-разрядных платформах Int может хранить любое значение от -2 147 483 648 до 2 147 483 647 
и является достаточно большим для многих целочисленных диапазонов.

<h3>UInt</h3> 

Swift также предоставляет целочисленный тип без знака, UInt, который имеет тот же размер, что и собственный размер текущей платформы:

            * On a 32-bit platform, UInt is the same size as UInt32.
            * On a 64-bit platform, UInt is the same size as UInt64.


    Используйте UInt только тогда, когда вам нужен целочисленный тип без знака с тем же размером, 
    что и собственный размер платформы.
    Если это не так, предпочтительнее Int, даже когда известно, что значения, 
    которые должны быть сохранены, неотрицательны.
    Последовательное использование Int для целочисленных значений способствует совместимости кода,
    устраняет необходимость преобразования между различными типами чисел и 
    соответствует выводу целочисленных типов, как описано в разделе  <a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID322">Type Safety and Type Inference.</a>

<h2>Числа с плавающей точкой / Floating-Point Numbers</h2>

<b>Числа с плавающей точкой</b> - это числа с дробной составляющей, такие как 3.14159, 0.1 и -273.15.

Типы с плавающей точкой могут представлять гораздо более широкий диапазон значений, чем целочисленные типы, 
и могут хранить числа, которые намного больше или меньше, чем могут быть сохранены в Int.

<ins>Swift предоставляет два типа чисел с плавающей точкой:<ins>

    <b>- Double</b> represents a 64-bit floating-point number.
    <b>- Float</b> represents a 32-bit floating-point number.

<b>Double имеет точность не менее 15 десятичных цифр, тогда как точность Float может составлять всего 6 десятичных цифр.
Соответствующий тип с плавающей точкой для использования зависит от природы и диапазона значений, 
с которыми вам нужно работать в вашем коде. В ситуациях, когда подходит любой тип, предпочтительнее Double.</b>

<h2>Тип безопасности и вывод типа</h2>

<b>Swift </b>- это язык, безопасный для типов.
Безопасный тип языка предлагает вам четко определить типы значений, с которыми может работать ваш код.
Если часть вашего кода требует <b>String</b>, вы не можете передать ему <b>Int</b> по ошибке.

Поскольку Swift является безопасным в использовании типов, он выполняет проверки типов при компиляции кода 
и помечает любые несовпадающие типы как ошибки.
Это позволяет вам выявлять и исправлять ошибки как можно раньше в процессе разработки.

Проверка типов помогает избежать ошибок при работе с различными типами значений.
Однако это не означает, что вы должны указывать тип каждой константы и переменной, которые вы объявляете.
Если вы не указали требуемый тип значения, Swift использует определение типа для определения подходящего типа.

Вывод типа позволяет компилятору автоматически определять тип определенного выражения при компиляции вашего кода, просто проверяя предоставленные вами значения.

Из-за вывода типов Swift требует гораздо меньше объявлений типов, чем такие языки, как C или Objective-C.
Константы и переменные по-прежнему явно типизированы, но большая часть работы по определению их типа сделана за вас.

Вывод типа особенно полезен, когда вы объявляете константу или переменную с начальным значением.
Это часто делается путем присвоения литерального значения (или литерала) константе или переменной в точке, в которой вы ее объявляете.
(Литеральное значение - это значение, которое отображается непосредственно в вашем исходном коде, например, 42 и 3.14159 в приведенных ниже примерах.)

Например, если вы присваиваете литералу значение 42 для новой константы, не говоря, какого она типа, 
Swift выведет, что вы хотите, чтобы константа была Int, потому что вы инициализировали ее числом, 
которое выглядит как целое число:

        let meaningOfLife = 42
        // meaningOfLife is inferred to be of type Int

Аналогично, если вы не указали тип литерала с плавающей запятой, Swift решит, что вы хотите создать Double:

        let pi = 3.14159
        // pi is inferred to be of type Double

Swift всегда выбирает Double (вместо Float), когда выводит тип чисел с плавающей точкой.

Если вы комбинируете целочисленные литералы и литералы с плавающей точкой в ​​выражении,
тип Double будет выведен из контекста:

        let anotherPi = 3 + 0.14159
        // anotherPi is also inferred to be of type Double

Буквальное значение <b>3 </b>не имеет явного типа само по себе, 
и поэтому соответствующий тип вывода Double выводится из-за 
присутствия литерала с плавающей запятой как части сложения.


<h2>Числовые литералы / Numeric Literals </h2>

<b>Целочисленные литералы могут быть записаны как:</b>

        - Десятичное число без префикса 
        - Двоичное число с префиксом -> 0b 
        - Восьмеричное число с префиксом -> 0o 
        - Шестнадцатеричное число с префиксом -> 0x

Все эти целочисленные литералы имеют десятичное значение 17:

        1 | let decimalInteger = 17
        2 | let binaryInteger = 0b10001       // 17 в двоичной записи
        3 | let octalInteger = 0o21           // 17 в восьмиричной записи
        4 | let hexadecimalInteger = 0x11     // 17 в шестнадцатиричной записи


Литералы с плавающей точкой могут быть десятичными (без префикса) или шестнадцатеричными (с префиксом 0x).
Они всегда должны иметь число (или шестнадцатеричное число) по обе стороны от десятичной точки.
Десятичные числа с плавающей запятой также могут иметь необязательный показатель степени, 
обозначаемый прописными или строчными буквами e; 
шестнадцатеричные числа с плавающей точкой должны иметь показатель степени, обозначенный заглавными или строчными буквами p.

Для десятичных чисел с показателем степени exp базовое число умножается на 10exp:

        1.25e2 means 1.25 x 102, or 125.0.
        1.25e-2 means 1.25 x 10-2, or 0.0125.


Для шестнадцатеричных чисел с показателем степени exp базовое число умножается на 2exp:

        0xFp2 means 15 x 22, or 60.0.
        0xFp-2 means 15 x 2-2, or 3.75.




Все эти литералы с плавающей точкой имеют десятичное значение 12,1875:


        let decimalDouble = 12.1875
        let exponentDouble = 1.21875e1
        let hexadecimalDouble = 0xC.3p0

Числовые литералы могут содержать дополнительное форматирование, чтобы их было легче читать.
И целые числа, и числа с плавающей точкой могут быть дополнены дополнительными нулями и могут содержать подчеркивания,
чтобы было удобно читать код. Ни один из типов форматирования не влияет на базовое значение литерала:

        let paddedDouble = 000123.456
        let oneMillion = 1_000_000
        let justOverOneMillion = 1_000_000.000_000_1
        
        
        
  <h2> Числовое Преобразование Типа  / Numeric Type Conversion </h2>
        
Используйте тип <b>Int</b> для всех целочисленных констант общего назначения и переменных в вашем коде
даже если известно, что они неотрицательны.     
Использование целочисленного типа по умолчанию в повседневных ситуациях означает, 
что целочисленные константы и переменные немедленно взаимодействуют в вашем коде 
и будут соответствовать выведенному типу для целочисленных литеральных значений.        
   
Используйте другие целочисленные типы только в том случае, если они особенно необходимы для выполняемой задачи,
из-за явного размера данных из внешнего источника или для производительности, 
использования памяти или другой необходимой оптимизации.  
   
Использование типов с явно заданными размерами в этих ситуациях помогает уловить 
любые случайные переполнения значений 
и неявно документирует природу используемых данных.        
        
  <h3>Целочисленное преобразование</h3>
  
Диапазон чисел, которые могут быть сохранены в целочисленной константе или переменной,
различен для каждого числового типа.
        
        Константа или переменная Int8 может хранить числа от -128 до 127
        
 в то время как
 
        Константа или переменная UInt8 может хранить числа от 0 до 255
        
Число, которое не помещается в константу или переменную целочисленного типа размера, 
сообщается как ошибка при компиляции кода:        
        
        
        let cannotBeNegative: UInt8 = -1
        // UInt8 cannot store negative numbers, and so this will report an error
        
        let tooBig: Int8 = Int8.max + 1
        // Int8 cannot store a number larger than its maximum value,
        // and so this will also report an error
        
        
  Поскольку каждый числовой тип может хранить различный диапазон значений, 
  вы должны выбрать преобразование числового типа в каждом конкретном случае.      
  Этот дополнительный подход предотвращает скрытые ошибки преобразования 
  и помогает четко определить намерения преобразования типа в вашем коде.      
        
  Чтобы преобразовать один конкретный тип номера в другой, вы инициализируете новый номер нужного типа с существующим значением.      
  В приведенном ниже примере константа twoThousand имеет тип UInt16, тогда как константа one - типа UInt8.      
  Они не могут быть добавлены вместе напрямую, потому что они не одного типа.      
  Вместо этого в этом примере вызывается UInt16 (one) для создания нового UInt16, 
  инициализированного значением one, и использует это значение вместо оригинала:

        let twoThousand: UInt16 = 2_000
        let one: UInt8 = 1
        let twoThousandAndOne = twoThousand + UInt16(one)

Поскольку обе стороны сложения теперь имеют тип UInt16, сложение разрешено.
Предполагается, что на выходе константа (twoThousandAndOne) имеет тип UInt16, поскольку она является суммой двух значений UInt16.

<b>SomeType (ofInitialValue)</b> является способом по умолчанию для вызова инициализатора типа Swift 
и передачи начального значения.
Под капотом UInt16 имеет инициализатор, который принимает значение UInt8, 
и поэтому этот инициализатор используется для создания нового UInt16 из существующего UInt8.
Однако вы не можете передавать здесь любой тип - это должен быть тип, для которого UInt16 предоставляет инициализатор.
Расширение существующих типов для обеспечения инициализаторов, которые принимают новые типы (включая ваши собственные определения типов), рассматривается в главе "Расширения"  <a href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html">Extensions.</a>


<h3>Целочисленное преобразование и преобразование с плавающей точкой</h3>

Преобразования между целочисленными и числовыми типами с плавающей точкой должны быть явными:

       | let three = 3
       | let pointOneFourOneFiveNine = 0.14159
       | let pi = Double(three) + pointOneFourOneFiveNine
        
        // pi equals 3.14159, and is inferred to be of type Double
        //Здесь значение константы три используется для создания нового значения типа Double, 
        //так что обе стороны сложения имеют одинаковый тип.

Без этого преобразования добавление не будет разрешено.

Преобразование с плавающей точкой в ​​целое также должно быть сделано явным. 
Целочисленный тип может быть инициализирован значением Double или Float:

        |let integerPi = Int(pi)
        
        // integerPi equals 3, and is inferred to be of type Int
Значения с плавающей точкой всегда усекаются при использовании для 
инициализации нового целочисленного значения таким способом. 

        Это означает, что 4,75 становится 4, а -3,9 становится -3.


        Правила объединения числовых констант и переменных отличаются от правил для числовых литералов.
        Литеральное значение 3 может быть добавлено непосредственно к литеральному значению 0.14159, 
        поскольку числовые литералы не имеют явного типа сами по себе.
        Их тип выводится только в тот момент, когда они оцениваются компилятором.
        
<h2> Тип Алиасы / Type Aliases </h2>      
        
Тип Алиасы - определяют альтернативное имя для существующего типа. 
Тип Алиасы - определяются с помощью ключевого слова typealias.
Тип Алиасы -полезны, когда вы хотите сослаться на существующий тип по имени, которое контекстуально более уместно, 
например, при работе с данными определенного размера из внешнего источника:   
        
        typealias AudioSample = UInt16
 
 Определив Тип Алиасы, вы можете использовать алиасы везде, где вы можете использовать исходное имя:       
        
        var maxAmplitudeFound = AudioSample.min
        // maxAmplitudeFound is now 0
        
 Здесь AudioSample определяется как псевдоним для UInt16. 
 Поскольку это алиас, вызов AudioSample.min фактически вызывает UInt16.min, 
 который предоставляет начальное значение 0 для переменной maxAmplitudeFound.       
        
  
  <h2> Логические типы / Booleans</h2>
    
  Swift имеет базовый логический тип, называемый Bool. 
  Логические значения называются логическими, потому что они могут быть только истинными или ложными. 
  
  <b>Swift предоставляет два значения логических констант: true и false:</b>
        
        
        let orangesAreOrange = true
        let turnipsAreDelicious = false
   
   Типы orangesAreOrange и turnipsAreDelicious были определены как Bool т.к., 
   они были инициализированы с логическими значениями литералов.     
        
   Как и в случае с Int и Double , вам не нужно объявлять константы или переменные как Bool, 
   если присваиваете им значение true или false, при создании.     
   Вывод типа помогает сделать код Swift более кратким и читаемым, 
   когда инициализирует константы или переменные с другими значениями, тип которых уже известен.
        
   Логические значения особенно полезны, когда вы работаете с условными операторами, такими как оператор if:     
        
        
            if turnipsAreDelicious {
                
                print("Mmm, tasty turnips!")
            
            } else {
                
                print("Eww, turnips are horrible.")
            }
            
            // Prints "Eww, turnips are horrible."     
        
   Условные операторы, такие как оператор if, более подробно описаны в главе <a href="https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html">Control Flow.</a>     
        
Безопасность типов Swift предотвращает замену Bool не-булевыми значениями. 

Следующий пример сообщает об ошибке времени компиляции:
        
        let i = 1
        
        if i {
        // this example will not compile, and will report an error
        }

Тем не менее, приведенный ниже альтернативный пример действителен:

        let i = 1
        if i == 1 {
            // this example will compile successfully
        }

Результат сравнения i == 1 имеет тип Bool, поэтому второй пример проходит проверку типа.
Сравнения типа i == 1 обсуждаются в разделе «Основные операторы».


Как и в случае с другими примерами безопасности типов в Swift, этот подход позволяет избежать случайных ошибок и гарантирует, что цель конкретного раздела кода всегда чистая.

<h2>Кортеж / Tuples</h2>

<b><ins>Кортежи</ins></b> группируют несколько значений в одно составное значение. 
Значения в кортеже могут быть любого типа и не обязательно должны быть одного типа друг с другом.

В этом примере (404, «Not Found») - это кортеж, который описывает код состояния HTTP. 
Код состояния HTTP - это специальное значение, возвращаемое веб-сервером каждый раз, когда вы запрашиваете веб-страницу.
Код состояния 404 Not Found возвращается, если вы запрашиваете несуществующую веб-страницу.


        let http404Error = (404, "Not Found")
        // http404Error is of type (Int, String), and equals (404, "Not Found")

Кортеж (404, «Not Found») группирует Int и String, чтобы дать коду статуса HTTP два отдельных значения:
число и удобочитаемое описание. 
Его можно описать как «кортеж типа (Int, String)».

Вы можете создавать кортежи из любой перестановки типов, и они могут содержать столько разных типов, сколько вам нужно. 
Ничто не мешает вам иметь кортеж типа (Int, Int, Int) или (String, Bool), 
или даже любую другую перестановку, которая вам требуется.


Вы можете <em>разложить</em> содержимое кортежа на отдельные константы или переменные, 
к которым вы затем получите доступ, как обычно:

        let (statusCode, statusMessage) = http404Error
        print("The status code is \(statusCode)")    // Prints "The status code is 404"
        
        print("The status message is \(statusMessage)")   // Prints "The status message is Not Found"
        

Если вам нужны только некоторые значения кортежа, игнорируйте части кортежа с подчеркиванием (_) 
при decompose / разворачивании кортежа:


        let (justTheStatusCode, _) = http404Error
        print("The status code is \(justTheStatusCode)")   // Prints "The status code is 404"
        
В качестве альтернативы, получить доступ к значениям отдельных элементов в кортеже, используя номера индекса,
начинающиеся с нуля:

        let http404Error = (404, "Not Found")
        print("The status code is \(http404Error.0)")   // Prints "The status code is 404"
        print("The status message is \(http404Error.1)")  // Prints "The status message is Not Found"
        
Вы можете назвать отдельные элементы в кортеже, когда кортеж определен:

        let http200Status = (statusCode: 200, description: "OK")

Если вы называете элементы в кортеже, вы можете использовать имена элементов для доступа к значениям этих элементов:
        
        let http200Status = (statusCode: 200, description: "OK")
        print("The status code is \(http200Status.statusCode)")  // Prints "The status code is 200 "
        print("The status message is \(http200Status.description)")  // Prints "The status message is OK"
        
 Кортежи особенно полезны в качестве возвращаемых значений функций. 
 Функция, которая пытается получить веб-страницу, может возвращать тип кортежа (Int, String), 
 чтобы описать успех или неудачу поиска страницы.       

Возвращая кортеж с двумя различными значениями, каждый из которых имеет свой тип, 
функция предоставляет более полезную информацию о своем результате, 
чем если бы она могла вернуть только одно значение одного типа.

Для получения дополнительной информации см. <a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID164">Функции с несколькими возвращаемыми значениями.</a>


            Кортежи полезны для временных групп связанных значений. 
            Они не подходят для создания сложных структур данных. 
            Если ваша структура данных может сохраняться за пределами временной области, 
            смоделируйте ее как класс или структуру, а не как кортеж.
            Для получения дополнительной информации см. Структуры и классы.

<h2>Optionals</h2>

Вы используете дополнительные функции в ситуациях, когда значение может отсутствовать. 
Optionals представляет две возможности:
Либо есть значение, и вы можете развернуть Optional для доступа к этому значению, 
либо значение вообще не существует.

        Концепция Optionals не существует в C или Objective-C. 
        Самая близкая вещь в Objective-C - это возможность вернуть nil из метода, 
        который иначе возвратил бы объект, при этом nil означает «отсутствие действительного объекта.»
        Однако это работает только для объектов - это не работает для структур, базовых типов C или значений перечисления. 
        Для этих типов методы Objective C обычно возвращают специальное значение (такое как NSNotFound), чтобы указать на               отсутствие значения.


        Этот подход предполагает, что вызывающий метод знает, что существует специальное значение для проверки, 
        и не забывает проверять его. Optionals Swift позволяют вам указать отсутствие значения для любого типа 
        вообще без необходимости использования специальных констант.


Вот пример того, как необязательные параметры могут использоваться, чтобы справиться с отсутствием значения. 
Тип Int в Swift имеет инициализатор, который пытается преобразовать значение String в значение Int. 

Однако не каждая строка может быть преобразована в целое число. 
Строка «123» может быть преобразована в числовое значение 123, но строка «привет, мир» 
не имеет очевидного числового значения для преобразования.

В приведенном ниже примере используется инициализатор, чтобы попытаться преобразовать String в Int:


        let possibleNumber = "123"
        let convertedNumber = Int(possibleNumber)
        // convertedNumber is inferred to be of type "Int?", or "optional Int"


Поскольку инициализатор может потерпеть неудачу, он возвращает необязательный Int, а не Int. 
Необязательный Int записывается как Int?, а не Int.

Знак вопроса ? указывает, что значение, которое оно содержит, является необязательным, 
то есть оно может содержать некоторое значение типа Int или вообще не содержать значения.
(Он не может содержать ничего другого, например значение Bool или значение String. 
Это либо Int, либо вообще ничего.)

<h3>nil</h3>

Вы устанавливаете необязательную переменную в состояние "ничего" , присваивая ей специальное значение nil:

        var serverResponseCode: Int? = 404
        // serverResponseCode содержит фактический Int со значением 404
        serverResponseCode = nil
        // serverResponseCode сейчас содержит значение - ничего 

    ПРИМЕЧАНИЕ:
    Вы не можете использовать nil с nonoptional константами и переменными. 
    Если константа или переменная в вашем коде должны работать с отсутствием значения при определенных условиях, 
    всегда объявляйте его как optional значение соответствующего типа.


Если вы определяете необязательную переменную без указания значения по умолчанию, 
для нее автоматически устанавливается nil:

        var surveyAnswer: String?
        // surveyAnswer is automatically set to nil

ПРИМЕЧАНИЕ:
nil Свифта не совпадает с nil в Objective-C. В Objective-C nil - указатель на несуществующий объект. 
В Swift nil не является указателем - это отсутствие значения определенного типа. 
Необязательные типы любого типа могут быть установлены на nil, а не только на типы объектов.


<h3>Оператор if и принудительное развертывание</h3>

Вы можете использовать оператор if, чтобы выяснить, содержит ли опциональное значение , 
сравнивая опциональное значение с nil.
Вы выполняете это сравнение с помощью оператора «равно» (==) или оператора «не равно» (! =).

Если необязательный параметр имеет значение, он считается «не равным» nil:


        if convertedNumber != nil {
            print("convertedNumber contains some integer value.")
        }
        // Prints "convertedNumber contains some integer value."


Убедившись в том, что optional содержит значение, вы можете получить доступ к его базовому значению, 
добавив восклицательный знак (!) В конце имени дополнительного элемента.

Восклицательный знак фактически говорит: «Я знаю, что эта опция определенно имеет значение; пожалуйста, используйте его ». 
Это называется принудительным развертыванием значения необязательного параметра:

        if convertedNumber != nil {
            print("convertedNumber has an integer value of \(convertedNumber!).")
        }
        // Prints "convertedNumber has an integer value of 123."
        
Для получения дополнительной информации об операторе if см. ,a href="https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html">Control Flow.</a>        
        
        
       ПРИМЕЧАНИЕ
       Пытаясь использовать! доступ к несуществующему необязательному значению вызывает ошибку во время выполнения. 
       Всегда убедитесь, что необязательный параметр содержит не-nil значение перед 
       использованием ! что-бы принудительно развернуть его значение.
        
        
<h3>Опциональная привязка</h3>

Вы используете необязательную привязку, чтобы выяснить, содержит ли необязательное значение, 
и если да, чтобы сделать это значение доступным в качестве временной константы или переменной.
Необязательное связывание может использоваться с операторами if и while для проверки значения внутри необязательного,        
и извлечь это значение в константу или переменную, как часть одного действия. операторы if и while более подробно 
описаны в Control Flow.       
        
 Напишите необязательную привязку для оператора if следующим образом:
 
             if let constantName = someOptional {
                statements
            }
        
 Вы можете переписать пример possibleNumber из раздела Optionals, чтобы использовать Optionals привязку 
 вместо принудительной распаковки:       
        
        if let actualNumber = Int(possibleNumber) {
            print("The string \"\(possibleNumber)\" has an integer value of \(actualNumber)")
        } else {
            print("The string \"\(possibleNumber)\" could not be converted to an integer")
        }
        // Prints "The string "123" has an integer value of 123"

Этот код можно прочитать как: 

«Если необязательный Int, возвращаемый Int (возможный номер), 
содержит значение, установите новую константу с именем actualNumber в значение, содержащееся в необязательном элементе».

Если преобразование прошло успешно, константа actualNumber становится доступной 
для использования в первой ветви оператора if. Он уже был инициализирован значением, 
содержащимся в необязательном значении, поэтому нет необходимости использовать! суффикс для доступа к его значению. 
В этом примере actualNumber просто используется для печати результата преобразования.

Вы можете использовать как константы, так и переменные с необязательной привязкой. 
Если вы хотите манипулировать значением factNumber в первой ветви оператора if, 
вы можете написать вместо него var actualNumber, и значение, содержащееся в необязательном элементе, 
будет доступно как переменная, а не как константа.

Вы можете включить столько необязательных привязок и логических условий в один оператор if, 
сколько вам нужно, через запятую. Если какое-либо из значений в необязательных привязках равно nil 
или какое-либо логическое условие оценивается как ложное, условие целого if считается ложным. 
Следующие операторы if эквивалентны:

            if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber < secondNumber && secondNumber < 100 {
                print("\(firstNumber) < \(secondNumber) < 100")
            }
            // Prints "4 < 42 < 100"

            if let firstNumber = Int("4") {
                if let secondNumber = Int("42") {
                    if firstNumber < secondNumber && secondNumber < 100 {
                        print("\(firstNumber) < \(secondNumber) < 100")
                    }
                }
            }
            // Prints "4 < 42 < 100"
            
        ПРИМЕЧАНИЕ

        Константы и переменные, созданные с необязательной привязкой в операторе if, доступны только в теле оператора if. 
        Напротив, константы и переменные, созданные с помощью оператора защиты, доступны в строках кода, 
        следующих за оператором охраны, как описано в разделе «Ранний выход».           

<h3>Неявно развернутые optionals</h3>
Как описано выше, необязательные параметры указывают, что константе или переменной 
разрешено иметь значение «без значения». Необязательные могут быть проверены с помощью оператора if, 
чтобы увидеть, существует ли значение, и могут быть условно развернуты с необязательным 
связыванием для доступа к значению необязательного, если оно существует.

Иногда из структуры программы ясно, что необязательный параметр всегда будет иметь 
значение после того, как это значение будет впервые установлено. В этих случаях полезно 
избавиться от необходимости проверять и развертывать значение необязательного значения при 
каждом обращении к нему, поскольку можно с уверенностью предположить, что оно всегда имеет значение.

Эти типы дополнительных опций определены как неявно развернутые дополнительные. 
Вы пишете неявно развернутый необязательный элемент, помещая восклицательный знак (String!) 
Вместо знака вопроса (String?) После типа, который вы хотите сделать необязательным.

Неявно развернутые необязательные параметры полезны, когда подтверждается, что значение 
необязательного значения существует сразу после того, как необязательное значение впервые определено, 
и определенно можно предположить, что оно существует в каждой точке после этого. 
Основное использование неявно развернутых необязательных опций в Swift происходит 
во время инициализации класса, как описано в «Неизвестных ссылках» и «Неявно развернутые необязательные свойства».

Неявно развернутый необязательный параметр является обычным необязательным за кулисами, 
но его также можно использовать как неопциональное значение, без необходимости развертывать 
необязательное значение при каждом обращении к нему. В следующем примере показано различие в 
поведении между необязательной строкой и неявно развернутой необязательной строкой 
при доступе к их переносимому значению в качестве явной строки:

            let possibleString: String? = "An optional string."
            let forcedString: String = possibleString! // requires an exclamation mark

            let assumedString: String! = "An implicitly unwrapped optional string."
            let implicitString: String = assumedString // no need for an exclamation mark
Вы можете думать о неявно развернутом дополнительном компоненте как о предоставлении 
разрешения на автоматическое развертывание дополнительного необязательного содержимого 
при каждом его использовании. Вместо того, чтобы ставить восклицательный знак после 
имени дополнительного элемента каждый раз, когда вы его используете, вы ставите 
восклицательный знак после типа дополнительного элемента при его объявлении.

            ПРИМЕЧАНИЕ
             Если неявно развернутый необязательный параметр равен nil 
             и вы пытаетесь получить доступ к его упакованному значению, 
             вы вызовете ошибку времени выполнения. Результат точно такой же, 
             как если бы вы поместили восклицательный знак после обычного необязательного, который не содержит значения.
Вы все еще можете обрабатывать неявно развернутый необязательный параметр как обычный необязательный,
чтобы проверить, содержит ли он значение:

            if assumedString != nil {
                print(assumedString!)
            }
            // Prints "An implicitly unwrapped optional string."


Вы также можете использовать неявно развернутый необязательный параметр с необязательным связыванием,
чтобы проверить и развернуть его значение в одном выражении:

            if let definiteString = assumedString {
                print(definiteString)
            }
            // Prints "An implicitly unwrapped optional string."
            
            
        ПРИМЕЧАНИЕ
        Не используйте неявно развернутый необязательный параметр, если существует вероятность того, 
        что переменная станет нулевой в более поздний момент. Всегда используйте обычный необязательный тип, 
        если вам нужно проверить значение nil в течение времени жизни переменной.

<h2>Обработка ошибок</h2>

Вы используете обработку ошибок, чтобы реагировать на ошибки, с которыми ваша программа может столкнуться во время выполнения.

В отличие от опций, которые могут использовать наличие или отсутствие значения для сообщения
об успехе или сбое функции, обработка ошибок позволяет вам определить основную причину сбоя и, 
при необходимости, распространить ошибку на другую часть вашей программы. ,

Когда функция встречает условие ошибки, она выдает ошибку. Вызывающий эту функцию может 
затем перехватить ошибку и ответить соответствующим образом.

        func canThrowAnError() throws {
            // this function may or may not throw an error
        }

Функция указывает, что может выдать ошибку, включив ключевое слово throws в свое объявление. 
Когда вы вызываете функцию, которая может выдать ошибку, вы добавляете ключевое слово try к выражению.

Swift автоматически распространяет ошибки из их текущей области, пока они не будут обработаны предложением catch.

            do {
                try canThrowAnError()
                // no error was thrown
            } catch {
                // an error was thrown
            }

Оператор do создает новую содержащую область, которая позволяет распространять ошибки в 
одном или нескольких предложениях catch. 

Вот пример того, как обработка ошибок может использоваться для реагирования на различные условия ошибки:

            func makeASandwich() throws {
                // ...
            }

            do {
                try makeASandwich()
                eatASandwich()
            } catch SandwichError.outOfCleanDishes {
                washDishes()
            } catch SandwichError.missingIngredients(let ingredients) {
                buyGroceries(ingredients)
            }

В этом примере функция makeASandwich () выдаст ошибку, если чистые блюда недоступны 
или отсутствуют какие-либо ингредиенты. Поскольку makeASandwich () может выдать ошибку, 
вызов функции заключен в выражение try. Оборачивая вызов функции в операторе do, 
любые выданные ошибки будут распространяться на предоставленные предложения catch.

Если ошибки не выдается, вызывается функция eatASandwich (). 
Если выдается ошибка и она соответствует случаю SandwichError.outOfCleanDishes, 
будет вызвана функция washDishes (). Если выдается ошибка и она соответствует случаю SandwichError.missingIngredients, 
то вызывается функция buyGroceries (_ :) со связанным значением [String], захваченным шаблоном catch.



<h3>Утверждения и предпосылки</h3>
        
Утверждения и предварительные условия - это проверки, которые происходят во время выполнения. 
Вы используете их, чтобы убедиться, что основное условие выполнено перед выполнением любого другого кода. 
Если логическое условие в утверждении или предварительном условии оценивается как true, 
выполнение кода продолжается как обычно. Если условие оценивается как ложное, 
текущее состояние программы недействительно; выполнение кода заканчивается, и ваше приложение прекращается.

Вы используете утверждения и предварительные условия, чтобы выразить свои предположения и ожидания, 
которые вы имеете при кодировании, чтобы вы могли включить их в свой код. Утверждения помогают 
вам находить ошибки и неверные предположения во время разработки, 
а предварительные условия помогают вам обнаруживать проблемы в работе.

Помимо проверки ваших ожиданий во время выполнения, утверждения и предварительные условия 
также становятся полезной формой документации в коде. В отличие от условий ошибок, 
описанных в разделе «Обработка ошибок» выше, утверждения и предварительные условия 
не используются для исправляемых или ожидаемых ошибок. 
Поскольку ошибочное утверждение или предварительное условие указывают 
на недопустимое состояние программы, невозможно отыскать ошибочное утверждение.

Использование утверждений и предварительных условий не заменяет разработку вашего кода таким образом, 
что вряд ли возникнут недопустимые условия. Однако использование их для обеспечения правильности данных
и состояния приводит к более предсказуемому завершению работы приложения
в случае возникновения недопустимого состояния и облегчает отладку проблемы.
Остановка выполнения при обнаружении недопустимого состояния также помогает ограничить ущерб, 
вызванный этим недопустимым состоянием.

Разница между утверждениями и предварительными условиями заключается в том, 
что они проверяются: утверждения проверяются только в отладочных сборках, 
а предварительные условия проверяются как в отладочных, так и в производственных сборках. 
В производственных сборках условие внутри утверждения не оценивается. 
Это означает, что вы можете использовать столько утверждений, 
сколько захотите в процессе разработки, не влияя на производительность в производственной среде.       
        
<h3>Отладка с утверждениями</h3>
Вы пишете утверждение, вызывая функцию assert (_: _: file: line :) из стандартной библиотеки Swift. 
Вы передаете этой функции выражение, которое оценивается как истинное или ложное, и сообщение, 
которое отображается, если результатом условия является ложное. 
Например:

            let age = -3
            assert(age >= 0, "A person's age can't be less than zero.")
            // This assertion fails because -3 is not >= 0.

В этом примере выполнение кода продолжается, если age> = 0, имеет значение true, 
то есть, если значение age неотрицательно. Если значение age отрицательно, 
как в приведенном выше коде, то age> = 0 оценивается как false, 
и утверждение не выполняется, и приложение завершается.

Вы можете опустить сообщение подтверждения - например, когда оно просто повторяет условие как прозу.

        assert(age >= 0)

Если код уже проверяет условие, вы используете функцию assertionFailure (_: file: line :), 
чтобы указать, что подтверждение не выполнено. 
Например:

        if age > 10 {
            print("You can ride the roller-coaster or the ferris wheel.")
        } else if age >= 0 {
            print("You can ride the ferris wheel.")
        } else {
            assertionFailure("A person's age can't be less than zero.")
        }
        
        
<h3>Выполнение предварительных условий</h3>
        
Используйте предварительное условие всякий раз, когда условие потенциально может быть ложным, 
но оно обязательно должно быть истинным, чтобы ваш код продолжал выполнение.        
Например, используйте предварительное условие, чтобы проверить, что нижний индекс не вышел за пределы, 
или чтобы убедиться, что функции передано допустимое значение.        
        

Вы пишете предварительное условие, вызывая функцию предварительного условия (_: _: file: line :). 
Вы передаете этой функции выражение, которое оценивается как истинное или ложное, и сообщение, 
которое отображается, если результатом условия является ложное. 
Например:     
        
        
           // В реализации нижнего индекса ...
        precondition(index > 0, "Index must be greater than zero.")     
        
Вы также можете вызвать функцию preconditionFailure (_: file: line :), 
чтобы указать, что произошел сбой - например, если был выбран the default case of a switch, 
но все действительные входные данные должны были обрабатываться одним из переключателей. других cases.        
        
        
        
        
        
        
        
        
        
        
        
        
        


